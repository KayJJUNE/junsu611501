import os
from dotenv import load_dotenv
import asyncio
from bot_selector import BotSelector
from character_bot import CharacterBot
import discord
from discord.ext import commands
import openai
from discord import Embed, app_commands
from typing import Dict, Any
from datetime import datetime
import langdetect
import sqlite3
from config import (CHARACTER_PROMPTS, OPENAI_API_KEY, CHARACTER_INFO,
                    CHARACTER_IMAGES, CHARACTER_AFFINITY_SPEECH,
                    AFFINITY_LEVELS)

# Load environment variables
load_dotenv()

# Get bot tokens from environment variables
SELECTOR_TOKEN = os.getenv('SELECTOR_TOKEN')
KAGARI_TOKEN = os.getenv('KAGARI_TOKEN')
EROS_TOKEN = os.getenv('EROS_TOKEN')
ELYSIA_TOKEN = os.getenv('ELYSIA_TOKEN')


async def run_bot(bot, token):
    try:
        await bot.start(token)
    except Exception as e:
        print(f"Error starting bot: {e}")


async def run_all_bots():
    try:
        # Initialize selector bot
        selector_bot = BotSelector()

        # Create character bots
        character_bots = {
            "Kagari": CharacterBot("Kagari", selector_bot),
            "Eros": CharacterBot("Eros", selector_bot),
            "Elysia": CharacterBot("Elysia", selector_bot)
        }

        # Set character_bots in selector_bot
        selector_bot.character_bots = character_bots

        # Create tasks for all bots
        tasks = [
            run_bot(selector_bot, SELECTOR_TOKEN),
            run_bot(character_bots["Kagari"], KAGARI_TOKEN),
            run_bot(character_bots["Eros"], EROS_TOKEN),
            run_bot(character_bots["Elysia"], ELYSIA_TOKEN)
        ]

        # Run all bots concurrently
        await asyncio.gather(*tasks)

    except Exception as e:
        print(f"Error occurred: {e}")
    finally:
        # Cleanup
        await selector_bot.close()
        for bot in character_bots.values():
            await bot.close()


class CharacterBot(commands.Bot):

    def __init__(self, character_name: str, bot_selector: Any):
        intents = discord.Intents.all()
        super().__init__(
            command_prefix='/',
            intents=intents,
            status=discord.Status.online,
            activity=discord.Game(name=f"Chatting as {character_name}"))

        # ê¸°ë³¸ ì†ì„± ì´ˆê¸°í™”
        self.character_name = character_name
        self.active_channels = {}
        self.message_history = {}
        self.db = DatabaseManager()
        self.bot_selector = bot_selector
        self.user_affinity_levels = {}
        self.last_message_time = {}
        self.chat_timers = {}

        # í”„ë¡¬í”„íŠ¸ ì„¤ì •
        base_prompt = CHARACTER_PROMPTS.get(character_name, "")
        self.prompt = base_prompt
        self.character_styles = CHARACTER_AFFINITY_SPEECH.get(
            character_name, {})

    async def setup_hook(self):
        """ë´‡ ì´ˆê¸°í™” ì‹œ í˜¸ì¶œë˜ëŠ” ë©”ì†Œë“œ"""
        print(f"{self.character_name} bot is initializing...")
        try:
            await self.tree.sync()
            print(f"{self.character_name} bot commands synced!")
            self.setup_commands()
        except Exception as e:
            print(f"Error syncing commands: {e}")

    def setup_commands(self):
        """ë´‡ ëª…ë ¹ì–´ ì„¤ì •"""
        @self.tree.command(
            name="ranking",
            description="ì „ì²´ ì‚¬ìš©ì ì¹œë°€ë„ ìˆœìœ„ í™•ì¸"
        )
        async def ranking_command(interaction: discord.Interaction):
            try:
                # ë­í‚¹ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                rankings, (user_rank, user_total_score) = \
                    self.db.get_affinity_ranking(interaction.user.id)
                if not rankings:
                    await interaction.response.send_message("ì•„ì§ ë­í‚¹ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
                    return

                embed = discord.Embed(
                    title="ğŸ† ì „ì²´ ì¹œë°€ë„ ë­í‚¹",
                    description="ëª¨ë“  ìºë¦­í„°ì™€ì˜ ì¹œë°€ë„ í•©ì‚° ìˆœìœ„ì…ë‹ˆë‹¤.",
                    color=discord.Color.gold()
                )
    
                # ìƒìœ„ 50ìœ„ í‘œì‹œ
                for user_id, total_score, rank in rankings:
                    user = self.get_user(user_id)
                    display_name = user.display_name if user else f"User{user_id}"

                    # í˜„ì¬ ì‚¬ìš©ìì˜ ìˆœìœ„ëŠ” êµµì€ ê¸€ì”¨ë¡œ í‘œì‹œ
                    if user_id == interaction.user.id:
                        name = f"{rank}ë“±: **{display_name}**"
                    else:
                        name = f"{rank}ë“±: {display_name}"

                    embed.add_field(
                        name=name,
                        value=f"ì´ ì¹œë°€ë„: {total_score}ì ",
                        inline=False
                    )

                # ì‚¬ìš©ìê°€ 50ìœ„ ë°–ì´ë©´ ë”°ë¡œ í‘œì‹œ
                if user_rank and user_rank > 50:
                    embed.add_field(
                        name="â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€",
                        value=f"**{user_rank}ë“±: {interaction.user.display_name}**",
                        inline=False
                    )

                await interaction.response.send_message(embed=embed)

            except Exception as e:
                print(f"Error in ranking display: {e}")
                await interaction.response.send_message("ë­í‚¹ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")

        @self.tree.command(
            name="affinity",
            description="ë‚´ ìºë¦­í„°ë³„ ì¹œë°€ë„ í™•ì¸"
        )
        async def affinity_command(interaction: discord.Interaction):
            try:
                # ì¹œë°€ë„ ì •ë³´ë¥¼ ë¹„ê³µê°œë¡œ ì „ì†¡
                await interaction.response.defer(ephemeral=True)

                # ì „ì²´ ìˆœìœ„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                rankings, user_rank_info = self.db.get_affinity_ranking(interaction.user.id)
                user_rank = user_rank_info[0] if user_rank_info else None
                user_total_score = user_rank_info[1]
                if not rankings:
                    await interaction.response.send_message("ì•„ì§ ë­í‚¹ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.")
                    return

                embed = discord.Embed(
                    title="ğŸ† ì „ì²´ ì¹œë°€ë„ ë­í‚¹",
                    description=f"ëª¨ë“  ìºë¦­í„°ì™€ì˜ ì¹œë°€ë„ í•©ì‚° ìˆœìœ„ì…ë‹ˆë‹¤.\ní˜„ì¬ {interaction.user.display_name}ë‹˜ì˜ ìˆœìœ„: {user_rank}ë“± (ì´ì : {user_total_score}ì )",
                    colour=discord.Color.gold()
                       # ìƒìœ„ 50ìœ„ í‘œì‹œ
                for i, (user_id, total_score, rank) in enumerate(rankings):
                            user = self.get_user(user_id)
                            display_name = user.display_name if user else f"User{user_id}"

                            # ìˆœìœ„ì— ë”°ë¥¸ ì´ëª¨ì§€ ì„¤ì •
                            rank_emoji = "ğŸ‘‘" if i == 0 else "ğŸ¥ˆ" if i == 1 else "ğŸ¥‰" if i == 2 else "âœ¨"

                            # í˜„ì¬ ì‚¬ìš©ìì˜ ìˆœìœ„ëŠ” êµµì€ ê¸€ì”¨ë¡œ í‘œì‹œ
                            if user_id == interaction.user.id:
                                name = f"{rank_emoji} {rank}ë“±: **{display_name}**"
                            else:
                                name = f"{rank_emoji} {rank}ë“±: {display_name}"

                            embed.add_field(
                                name=name,
                                value=f"ì´ ì¹œë°€ë„: {total_score}ì ",
                                inline=False
                    
                # ìºë¦­í„°ë³„ ì¹œë°€ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                character_affinities = self.db.get_user_affinity(interaction.user.id)

                rank_text = f"{user_rank}ë“±" if user_rank else "ìˆœìœ„ ì—†ìŒ"

                Embed = discord.Embed(
                    title=f"ğŸ’ {interaction.user.display_name}ë‹˜ì˜ ì¹œë°€ë„ ì •ë³´",
                    description=f"í˜„ì¬ ì „ì²´ ìˆœìœ„: {f'{user_rank}ë“±' if user_rank else 'ìˆœìœ„ ì—†ìŒ'} (ì´ì : {user_total_score}ì )",
                    colour=discord.Color.purple()
                     )
                
                total_score = 0
                for char_name, score, daily_count, last_time in character_affinities:
                    total_score += score

                    # ì¹œë°€ë„ ë ˆë²¨ ê³„ì‚°
                    level = "ë‚®ìŒ"
                    if score >= 100:
                        level = "ë§¤ìš° ë†’ìŒ"
                    elif score >= 50:
                        level = "ë†’ìŒ"
                    elif score >= 20:
                        level = "ë³´í†µ"

                    # ë§ˆì§€ë§‰ ëŒ€í™” ì‹œê°„ ê³„ì‚°
                    if last_time:
                        last_time = datetime.strptime(last_time, "%Y-%m-%d %H:%M:%S")
                        time_diff = datetime.now() - last_time
                        if time_diff.days > 0:
                            last_chat = f"{time_diff.days}ì¼ ì „"
                        elif time_diff.seconds // 3600 > 0:
                            last_chat = f"{time_diff.seconds // 3600}ì‹œê°„ ì „"
                        else:
                            last_chat = f"{time_diff.seconds // 60}ë¶„ ì „"
                    else:
                        last_chat = "ì—†ìŒ"

                    embed.add_field(
                        name=f"âœ¨ {char_name}",
                        value=f"ì¹œë°€ë„: {score}ì  ({level})\n"
                              f"ì˜¤ëŠ˜ ëŒ€í™”: {daily_count}íšŒ\n"
                              f"ë§ˆì§€ë§‰ ëŒ€í™”: {last_chat}",
                        inline=False
                    )

                embed.set_footer(text=f"ì´ ì¹œë°€ë„: {total_score}ì ")
                await interaction.followup.send(embed=embed, ephemeral=True)

            except Exception as e:
                print(f"Error in affinity command: {e}")
                await interaction.followup.send(
                    "ì¹œë°€ë„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
                    ephemeral=True
                )

        @self.tree.command(name="affinity", description="ë‚´ ìºë¦­í„°ë³„ ì¹œë°€ë„ í™•ì¸")
        async def affinity_command(interaction: discord.Interaction):
            try:
                affinity_info = self.db.get_affinity(interaction.user.id,
                                                     self.character_name)
                score = affinity_info.get('score', 0)
                daily_count = affinity_info.get('daily_count', 0)

                embed = discord.Embed(
                    title="ğŸ’ ìºë¦­í„°ë³„ ì¹œë°€ë„",
                    description=f"{interaction.user.name}ë‹˜ì˜ ìºë¦­í„°ë³„ ì¹œë°€ë„ì…ë‹ˆë‹¤.",
                    colour=discord.Color.purple())

                # ê° ìºë¦­í„°ë³„ ì¹œë°€ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                for char_name in ["Kagari", "Eros", "Elysia"]:
                    affinity_info = self.db.get_affinity(
                        interaction.user.id, char_name)

                    # ì¹œë°€ë„ ë ˆë²¨ ê³„ì‚°
                    level = "ë‚®ìŒ"
                    if affinity_info['score'] >= 100:
                        level = "ë§¤ìš° ë†’ìŒ"
                    elif affinity_info['score'] >= 50:
                        level = "ë†’ìŒ"
                    elif affinity_info['score'] >= 20:
                        level = "ë³´í†µ"

                    embed.add_field(
                        name=f"âœ¨ {char_name}",
                        value=
                        f"ì¹œë°€ë„: {affinity_info['score']}ì  ({level})\nì˜¤ëŠ˜ ì±„íŒ…: {affinity_info['daily_count']}íšŒ",
                        inline=False)

                await interaction.response.send_message(embed=embed)

            except Exception as e:
                print(f"Error in affinity command: {e}")
                await interaction.response.send_message(
                    "ì¹œë°€ë„ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", ephemeral=True)

    async def add_channel(self, channel_id: int,
                          user_id: int) -> tuple[bool, str]:
        """ì±„ë„ í™œì„±í™”"""
        try:
            if channel_id in self.active_channels:
                return False, "ì´ë¯¸ í™œì„±í™”ëœ ì±„ë„ì…ë‹ˆë‹¤."

            self.active_channels[channel_id] = {
                "user_id": user_id,
                "history": []
            }
            self.message_history[channel_id] = []
            return True, "ì±„ë„ì´ ì„±ê³µì ìœ¼ë¡œ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤."

        except Exception as e:
            print(f"Error in add_channel: {e}")
            return False, "ì±„ë„ í™œì„±í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."

    def get_intimacy_prompt(self, intimacy_level: int) -> str:
        """ì¹œë°€ë„ ë ˆë²¨ì— ë”°ë¥¸ í”„ë¡¬í”„íŠ¸ ìƒì„±"""
        try:
            affinity_level = "low"
            if intimacy_level >= AFFINITY_LEVELS["high"][0]:
                affinity_level = "high"
            elif intimacy_level >= AFFINITY_LEVELS["medium"][0]:
                affinity_level = "medium"

            speech_pattern = CHARACTER_AFFINITY_SPEECH[
                self.character_name][affinity_level]
            prompt = f"{self.prompt}\n\nCurrent affinity level: {affinity_level}\nTone: {speech_pattern['tone']}"
            return prompt
        except Exception as e:
            print(f"Error in get_intimacy_prompt: {e}")
            return self.prompt

    async def get_ai_response(self, messages: list) -> str:
        """OpenAI APIë¥¼ í†µí•œ ì‘ë‹µ ìƒì„±"""
        try:
            response = await openai.ChatCompletion.acreate(
                model="gpt-4-turbo-preview",
                messages=messages,
                temperature=0.7,
                max_tokens=1000,
                presence_penalty=0.6,
                frequency_penalty=0.3)
            return response.choices[0].message.content
        except Exception as e:
            print(f"Error in AI response generation: {e}")
            return "ì£„ì†¡í•©ë‹ˆë‹¤. ì‘ë‹µì„ ìƒì„±í•˜ëŠ” ì¤‘ì— ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."

    async def send_response_with_intimacy(self, message, response: str,
                                          intimacy_level: int):
        """ì¹œë°€ë„ ë ˆë²¨ì— ë”°ë¥¸ ì‘ë‹µ ì „ì†¡"""
        try:
            async with message.channel.typing():
                await asyncio.sleep(len(response) * 0.05)
                await message.channel.send(response)

                self.db.add_message(message.channel.id, message.author.id,
                                    self.character_name, "assistant", response)
        except Exception as e:
            print(f"Error in sending response: {e}")
            await message.channel.send(response)

    async def on_message(self, message):
        """ë©”ì‹œì§€ ìˆ˜ì‹  ì‹œ í˜¸ì¶œë˜ëŠ” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬"""
        if message.author.bot or not message.guild:
            return

        if message.content.startswith('/'):
            await super().on_message(message)
            return

        if message.channel.id not in self.active_channels:
            return

        try:
            # ì¹œë°€ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            affinity_info = self.db.get_affinity(message.author.id,
                                                 self.character_name)
            affinity_score = affinity_info[
                "affinity_score"] if affinity_info else 0

            # ì¹œë°€ë„ ë ˆë²¨ ê³„ì‚°
            affinity_level = "low"
            if affinity_score >= 70:
                affinity_level = "high"
            elif affinity_score >= 30:
                affinity_level = "medium"

            # ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì¤€ë¹„
            system_prompt = self.get_intimacy_prompt(affinity_score)
            messages = [{"role": "system", "content": system_prompt}]

            # medium ë ˆë²¨ ì´ìƒì¼ ë•Œë§Œ ì´ì „ ëŒ€í™” ê¸°ë¡ ê°€ì ¸ì˜¤ê¸°
            if affinity_level != "low":
                recent_messages = self.db.get_recent_messages(
                    channel_id=message.channel.id,
                    limit=30,  # ìƒìœ„ 30ê°œ ë©”ì‹œì§€ë§Œ
                    user_id=message.author.id  # í•´ë‹¹ ì‚¬ìš©ìì˜ ë©”ì‹œì§€ë§Œ
                )

                # ì‚¬ìš©ì ì´ë¦„ ì •ë³´ ì¶”ê°€
                user_name = message.author.display_name
                context_message = {
                    "role":
                    "system",
                    "content":
                    f"ì´ ì‚¬ìš©ìì˜ ì´ë¦„ì€ {user_name}ì…ë‹ˆë‹¤. ëŒ€í™”í•  ë•Œ ì´ë¦„ì„ ìì—°ìŠ¤ëŸ½ê²Œ ë¶€ë¥´ë©° ì´ì „ ëŒ€í™”ë¥¼ ì°¸ê³ í•˜ì„¸ìš”."
                }
                messages.append(context_message)
                messages.extend(recent_messages)
            else:
                # low ë ˆë²¨ì¼ ë•ŒëŠ” ì´ë¦„ë§Œ ì „ë‹¬
                user_name = message.author.display_name
                context_message = {
                    "role": "system",
                    "content": f"ì´ ì‚¬ìš©ìì˜ ì´ë¦„ì€ {user_name}ì…ë‹ˆë‹¤. ì²˜ìŒ ë§Œë‚œ ì‚¬ìš©ìì²˜ëŸ¼ ëŒ€í™”í•˜ì„¸ìš”."
                }
                messages.append(context_message)

            # í˜„ì¬ ë©”ì‹œì§€ ì¶”ê°€
            current_message = {"role": "user", "content": message.content}
            messages.append(current_message)

            # ì‘ë‹µ ìƒì„± ë° ì „ì†¡
            response = await self.get_ai_response(messages)
            await self.send_response_with_intimacy(message, response,
                                                   affinity_score)

            # ì¹œë°€ë„ ì—…ë°ì´íŠ¸
            self.db.update_affinity(message.author.id, self.character_name,
                                    message.content, str(datetime.now()))

        except Exception as e:
            print(f"Error in message processing: {e}")
            await message.channel.send("ì£„ì†¡í•©ë‹ˆë‹¤. ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")


def get_affinity(self, user_id: int, character_name: str) -> dict:
    """ì¹œë°€ë„ ì •ë³´ ì¡°íšŒ"""
    with sqlite3.connect(self.db_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            '''
            INSERT OR IGNORE INTO affinity 
            (user_id, character_name, last_daily_reset)
            VALUES (?, ?, date('now'))
        ''', (user_id, character_name))

        cursor.execute(
            '''
            SELECT affinity_score, daily_message_count, last_daily_reset,
                   last_message_time, last_message_content
            FROM affinity
            WHERE user_id = ? AND character_name = ?
        ''', (user_id, character_name))

        result = cursor.fetchone()
        return {
            "score": result[0],
            "daily_count": result[1],
            "last_reset": result[2],
            "last_time": result[3],
            "last_content": result[4]
        }


def update_affinity(self, user_id: int, character_name: str,
                    message_content: str, current_time: str):
    """ì¹œë°€ë„ ì—…ë°ì´íŠ¸"""
    with sqlite3.connect(self.db_name) as conn:
        cursor = conn.cursor()

        # ì¼ì¼ ë¦¬ì…‹ í™•ì¸
        cursor.execute(
            '''
            UPDATE affinity 
            SET daily_message_count = daily_message_count + 1
            WHERE user_id = ? 
            AND character_name = ?
            AND last_daily_reset = date('now')
        ''', (user_id, character_name))

        # ìƒˆë¡œìš´ ë‚ ì§œë©´ ë¦¬ì…‹
        cursor.execute(
            '''
            UPDATE affinity 
            SET daily_message_count = 1,
                last_daily_reset = date('now')
            WHERE user_id = ? 
            AND character_name = ?
            AND last_daily_reset < date('now')
        ''', (user_id, character_name))

        # ë©”ì‹œì§€ ì •ë³´ ì—…ë°ì´íŠ¸
        cursor.execute(
            '''
            UPDATE affinity
            SET last_message_time = ?,
                last_message_content = ?
            WHERE user_id = ? AND character_name = ?
        ''', (current_time, message_content, user_id, character_name))

        conn.commit()


def get_affinity_ranking(self, limit: int = 10):
    """ì¹œë°€ë„ ë­í‚¹ ì¡°íšŒ"""
    with sqlite3.connect(self.db_name) as conn:
        cursor = conn.cursor()
        cursor.execute(
            '''
            SELECT user_id, SUM(affinity_score) as total_score
            FROM affinity
            GROUP BY user_id
            HAVING total_score > 0
            ORDER BY total_score DESC
            LIMIT ?
        ''', (limit, ))
        return cursor.fetchall()


class DatabaseManager:
    def __init__(self):
        self.db_name = "chatbot.db"
        self.setup_database()

    def get_affinity(self, user_id: int, character_name: str) -> dict:
        """ì‚¬ìš©ìì˜ íŠ¹ì • ìºë¦­í„°ì™€ì˜ ì¹œë°€ë„ ì •ë³´ ì¡°íšŒ"""
        try:
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()

                # í˜„ì¬ ë‚ ì§œì™€ ë§ˆì§€ë§‰ ë¦¬ì…‹ ë‚ ì§œê°€ ë‹¤ë¥´ë©´ daily_count ë¦¬ì…‹
                cursor.execute('''
                    UPDATE affinity 
                    SET daily_message_count = 0, 
                        last_daily_reset = date('now')
                    WHERE user_id = ? 
                    AND character_name = ?
                    AND last_daily_reset < date('now')
                ''', (user_id, character_name))

                # ì¹œë°€ë„ ì •ë³´ê°€ ì—†ìœ¼ë©´ ìƒì„±
                cursor.execute('''
                    INSERT OR IGNORE INTO affinity 
                    (user_id, character_name, affinity_score, daily_message_count) 
                    VALUES (?, ?, 0, 0)
                ''', (user_id, character_name))

                # ì¹œë°€ë„ ì •ë³´ ì¡°íšŒ
                cursor.execute('''
                    SELECT affinity_score, daily_message_count,
                           last_daily_reset, last_message_time
                    FROM affinity
                    WHERE user_id = ? AND character_name = ?
                ''', (user_id, character_name))

                result = cursor.fetchone()
                conn.commit()

                if not result:
                    return {
                        'affinity_score': 0,
                        'daily_count': 0,
                        'last_reset': None,
                        'last_time': None
                    }

                return {
                    'affinity_score': result[0],
                    'daily_count': result[1],
                    'last_reset': result[2],
                    'last_time': result[3]
                }

        except sqlite3.Error as e:
            print(f"Database error in get_affinity: {e}")
            return {
                'affinity_score': 0,
                'daily_count': 0,
                'last_reset': None,
                'last_time': None
            }

    def get_affinity_ranking(self, user_id: int = None) -> tuple[list, tuple]:
        """ì „ì²´ ì¹œë°€ë„ ë­í‚¹ ì¡°íšŒ ë° íŠ¹ì • ìœ ì €ì˜ ìˆœìœ„ ë°˜í™˜"""
        try:
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()

                # ì „ì²´ ë­í‚¹ ì¡°íšŒ (ìƒìœ„ 50ìœ„)
                cursor.execute('''
                    WITH RankedUsers AS (
                        SELECT 
                            user_id,
                            SUM(affinity_score) as total_score,
                            RANK() OVER (ORDER BY SUM(affinity_score) DESC) as rank
                        FROM affinity
                        GROUP BY user_id
                        HAVING total_score > 0
                    )
                    SELECT user_id, total_score, rank
                    FROM RankedUsers
                    WHERE rank <= 50
                    ORDER BY rank
                ''')
                top_50_rankings = cursor.fetchall()

                if user_id:
                    # íŠ¹ì • ìœ ì €ì˜ ìˆœìœ„ì™€ ì´ì  ì¡°íšŒ
                    cursor.execute('''
                        WITH RankedUsers AS (
                            SELECT 
                                user_id,
                                SUM(affinity_score) as total_score,
                                RANK() OVER (ORDER BY SUM(affinity_score) DESC) as rank
                            FROM affinity
                            GROUP BY user_id
                            HAVING total_score > 0
                        )
                        SELECT rank, total_score
                        FROM RankedUsers
                        WHERE user_id = ?
                    ''', (user_id,))

                    user_rank_info = cursor.fetchone()
                    if user_rank_info:
                        return top_50_rankings, (user_rank_info[0], user_rank_info[1])

                    # ìˆœìœ„ëŠ” ì—†ì§€ë§Œ ì´ì ì€ ìˆì„ ìˆ˜ ìˆìŒ
                    cursor.execute('''
                        SELECT SUM(affinity_score) as total_score
                        FROM affinity
                        WHERE user_id = ?
                    ''', (user_id,))
                    total_score = cursor.fetchone()[0] or 0
                    return top_50_rankings, (None, total_score)

                return top_50_rankings, (None, 0)

        except sqlite3.Error as e:
            print(f"Database error in get_affinity_ranking: {e}")
            return [], (None, 0)

    def update_affinity(self, user_id: int, character_name: str, last_message: str, last_message_time: str):
        """ì¹œë°€ë„ ì •ë³´ ì—…ë°ì´íŠ¸"""
        try:
            with sqlite3.connect(self.db_name) as conn:
                cursor = conn.cursor()

                # í˜„ì¬ ì¹œë°€ë„ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                cursor.execute('''
                    SELECT affinity_score, daily_message_count
                    FROM affinity
                    WHERE user_id = ? AND character_name = ?
                ''', (user_id, character_name))

                result = cursor.fetchone()
                current_score = result[0] if result else 0
                daily_count = result[1] if result else 0

                # ì¼ì¼ ëŒ€í™” ìˆ˜ì— ë”°ë¥¸ ì¹œë°€ë„ ë³´ìƒ
                score_change = 1  # ê¸°ë³¸ ì¦ê°€ê°’
                if daily_count == 9:  # 10ë²ˆì§¸ ëŒ€í™”
                    score_change = 5
                elif daily_count == 29:  # 30ë²ˆì§¸ ëŒ€í™”
                    score_change = 3

                # ìµœëŒ€ ì¹œë°€ë„(100) ì œí•œ
                new_score = min(100, current_score + score_change)

                # ì¹œë°€ë„ ì—…ë°ì´íŠ¸
                cursor.execute('''
                    INSERT OR REPLACE INTO affinity 
                    (user_id, character_name, affinity_score, daily_message_count, 
                    last_message_content, last_message_time)
                    VALUES (?, ?, ?, ?, ?, ?)
                ''', (user_id, character_name, new_score, daily_count + 1, 
                      last_message, last_message_time))

                conn.commit()
                return True

        except sqlite3.Error as e:
            print(f"Database error in update_affinity: {e}")
            return False
